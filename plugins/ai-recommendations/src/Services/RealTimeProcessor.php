<?php

declare(strict_types=1);

namespace AIRecommendations\Services;

use AIRecommendations\Repository\BehaviorRepository;
use Shopologic\Core\Logger\LoggerInterface;
use Shopologic\Core\Cache\CacheInterface;
use Shopologic\Core\Queue\QueueInterface;

/**
 * Real-Time Recommendation Processor
 * 
 * Provides instant recommendation updates based on user behavior:
 * - Stream processing for real-time events
 * - Incremental model updates
 * - Low-latency recommendation serving
 * - Event-driven personalization
 * - Hot and cold recommendation caching
 */
class RealTimeProcessor
{
    private HybridRecommender $hybridRecommender;
    private BehaviorRepository $behaviorRepository;
    private LoggerInterface $logger;
    private CacheInterface $cache;
    private QueueInterface $queue;
    private array $config;
    
    // Event types that trigger immediate updates
    private const HIGH_PRIORITY_EVENTS = [
        'purchase',
        'add_to_cart',\n        'rating',\n        'add_to_wishlist',\n        'product_view',\n        'search_query'\n    ];\n    \n    // Cache layers for different recommendation types\n    private const CACHE_LAYERS = [\n        'hot' => 60,        // 1 minute for high-activity users\n        'warm' => 300,      // 5 minutes for moderate activity\n        'cold' => 1800,     // 30 minutes for low activity\n        'global' => 3600    // 1 hour for global trends\n    ];\n    \n    public function __construct(\n        HybridRecommender $hybridRecommender,\n        BehaviorRepository $behaviorRepository,\n        array $config = []\n    ) {\n        $this->hybridRecommender = $hybridRecommender;\n        $this->behaviorRepository = $behaviorRepository;\n        $this->config = array_merge([\n            'enabled' => true,\n            'update_frequency_seconds' => 60,\n            'batch_size' => 100,\n            'max_queue_size' => 10000,\n            'cache_duration' => 3600,\n            'immediate_update_threshold' => 5,\n            'user_activity_tracking' => true,\n            'real_time_features' => true,\n            'stream_processing' => true\n        ], $config);\n    }\n    \n    /**\n     * Process real-time user behavior event\n     */\n    public function processEvent(array $event): array\n    {\n        try {\n            // Validate event data\n            $this->validateEvent($event);\n            \n            // Determine event priority\n            $priority = $this->getEventPriority($event);\n            \n            // Store event in behavior repository\n            $this->behaviorRepository->storeEvent($event);\n            \n            // Update user activity tracking\n            if ($this->config['user_activity_tracking']) {\n                $this->updateUserActivity($event['user_id'], $event['event_type']);\n            }\n            \n            // Process based on priority\n            if ($priority === 'high') {\n                // Immediate processing for high-priority events\n                $result = $this->processImmediateUpdate($event);\n            } else {\n                // Queue for batch processing\n                $result = $this->queueForBatchProcessing($event);\n            }\n            \n            // Update real-time features\n            if ($this->config['real_time_features']) {\n                $this->updateRealTimeFeatures($event);\n            }\n            \n            return [\n                'success' => true,\n                'event_id' => $event['event_id'] ?? uniqid(),\n                'processing_type' => $priority === 'high' ? 'immediate' : 'queued',\n                'recommendations_updated' => $result['updated'] ?? false,\n                'cache_invalidated' => $result['cache_invalidated'] ?? false\n            ];\n            \n        } catch (\\Exception $e) {\n            $this->logger->error('Real-time event processing failed', [\n                'error' => $e->getMessage(),\n                'event' => $event\n            ]);\n            \n            return [\n                'success' => false,\n                'error' => $e->getMessage()\n            ];\n        }\n    }\n    \n    /**\n     * Get real-time recommendations for a user\n     */\n    public function getRealTimeRecommendations(string $userId, array $context = []): array\n    {\n        try {\n            // Determine user activity level\n            $activityLevel = $this->getUserActivityLevel($userId);\n            \n            // Select appropriate cache layer\n            $cacheKey = $this->generateCacheKey($userId, $context);\n            $cacheDuration = self::CACHE_LAYERS[$activityLevel];\n            \n            // Try to get from cache first\n            $cached = $this->cache->get($cacheKey);\n            if ($cached && $this->isCacheValid($cached, $activityLevel)) {\n                return $this->enhanceWithRealTimeContext($cached, $context);\n            }\n            \n            // Generate fresh recommendations\n            $recommendations = $this->generateFreshRecommendations($userId, $context);\n            \n            // Apply real-time adjustments\n            $recommendations = $this->applyRealTimeAdjustments($recommendations, $userId, $context);\n            \n            // Cache the results\n            $this->cache->put($cacheKey, $recommendations, $cacheDuration);\n            \n            return $recommendations;\n            \n        } catch (\\Exception $e) {\n            $this->logger->error('Real-time recommendation generation failed', [\n                'error' => $e->getMessage(),\n                'user_id' => $userId\n            ]);\n            \n            // Fallback to cached or default recommendations\n            return $this->getFallbackRecommendations($userId, $context);\n        }\n    }\n    \n    /**\n     * Process immediate updates for high-priority events\n     */\n    private function processImmediateUpdate(array $event): array\n    {\n        $userId = $event['user_id'];\n        $eventType = $event['event_type'];\n        \n        $result = [\n            'updated' => false,\n            'cache_invalidated' => false\n        ];\n        \n        // Invalidate user's recommendation cache\n        $this->invalidateUserCache($userId);\n        $result['cache_invalidated'] = true;\n        \n        // Update user's immediate preferences\n        $this->updateImmediatePreferences($event);\n        \n        // Generate new recommendations if user is currently active\n        if ($this->isUserCurrentlyActive($userId)) {\n            $newRecommendations = $this->generateFreshRecommendations($userId, [\n                'triggered_by_event' => $eventType,\n                'immediate_context' => $event\n            ]);\n            \n            // Store in hot cache\n            $cacheKey = $this->generateCacheKey($userId, ['immediate' => true]);\n            $this->cache->put($cacheKey, $newRecommendations, self::CACHE_LAYERS['hot']);\n            \n            $result['updated'] = true;\n        }\n        \n        // Update real-time trends if applicable\n        if (in_array($eventType, ['purchase', 'add_to_cart'])) {\n            $this->updateTrendingItems($event);\n        }\n        \n        return $result;\n    }\n    \n    /**\n     * Queue event for batch processing\n     */\n    private function queueForBatchProcessing(array $event): array\n    {\n        // Add to processing queue\n        $this->queue->push('recommendations.process_event', $event, [\n            'delay' => 0,\n            'priority' => $this->getQueuePriority($event)\n        ]);\n        \n        return [\n            'updated' => false,\n            'cache_invalidated' => false,\n            'queued' => true\n        ];\n    }\n    \n    /**\n     * Process queued events in batches\n     */\n    public function processBatchEvents(): void\n    {\n        try {\n            $batchSize = $this->config['batch_size'];\n            $events = $this->queue->getBatch('recommendations.process_event', $batchSize);\n            \n            if (empty($events)) {\n                return;\n            }\n            \n            // Group events by user for efficient processing\n            $eventsByUser = $this->groupEventsByUser($events);\n            \n            $processedUsers = 0;\n            $updatedRecommendations = 0;\n            \n            foreach ($eventsByUser as $userId => $userEvents) {\n                $updated = $this->processBatchForUser($userId, $userEvents);\n                $processedUsers++;\n                \n                if ($updated) {\n                    $updatedRecommendations++;\n                }\n            }\n            \n            $this->logger->info('Batch event processing completed', [\n                'events_processed' => count($events),\n                'users_processed' => $processedUsers,\n                'recommendations_updated' => $updatedRecommendations\n            ]);\n            \n        } catch (\\Exception $e) {\n            $this->logger->error('Batch event processing failed', [\n                'error' => $e->getMessage()\n            ]);\n        }\n    }\n    \n    /**\n     * Process batch of events for a specific user\n     */\n    private function processBatchForUser(string $userId, array $events): bool\n    {\n        // Analyze event patterns\n        $patterns = $this->analyzeEventPatterns($events);\n        \n        // Update user behavior profile\n        $this->updateUserBehaviorProfile($userId, $patterns);\n        \n        // Determine if recommendations need updating\n        $needsUpdate = $this->shouldUpdateRecommendations($userId, $patterns);\n        \n        if ($needsUpdate) {\n            // Invalidate existing cache\n            $this->invalidateUserCache($userId);\n            \n            // Pre-generate recommendations for next request\n            $this->preGenerateRecommendations($userId, $patterns);\n            \n            return true;\n        }\n        \n        return false;\n    }\n    \n    /**\n     * Apply real-time adjustments to recommendations\n     */\n    private function applyRealTimeAdjustments(array $recommendations, string $userId, array $context): array\n    {\n        // Get recent user behavior\n        $recentBehavior = $this->behaviorRepository->getRecentBehavior($userId, 3600); // Last hour\n        \n        foreach ($recommendations as &$recommendation) {\n            // Boost items similar to recently viewed\n            $similarity = $this->calculateRecentSimilarity($recommendation['item_id'], $recentBehavior);\n            $recommendation['score'] += $similarity * 0.1;\n            \n            // Apply time-based adjustments\n            $timeBoost = $this->calculateTimeBasedBoost($recommendation['item_id'], $context);\n            $recommendation['score'] += $timeBoost;\n            \n            // Apply trending boost\n            $trendingBoost = $this->calculateTrendingBoost($recommendation['item_id']);\n            $recommendation['score'] += $trendingBoost;\n            \n            // Apply inventory availability adjustment\n            $availabilityBoost = $this->calculateAvailabilityBoost($recommendation['item_id']);\n            $recommendation['score'] *= $availabilityBoost;\n            \n            // Add real-time confidence score\n            $recommendation['real_time_confidence'] = $this->calculateRealTimeConfidence(\n                $recommendation,\n                $recentBehavior,\n                $context\n            );\n        }\n        \n        // Re-sort by adjusted scores\n        usort($recommendations, fn($a, $b) => $b['score'] <=> $a['score']);\n        \n        return $recommendations;\n    }\n    \n    /**\n     * Update real-time features based on events\n     */\n    private function updateRealTimeFeatures(array $event): void\n    {\n        $userId = $event['user_id'];\n        $eventType = $event['event_type'];\n        $timestamp = $event['timestamp'] ?? time();\n        \n        // Update session features\n        $this->updateSessionFeatures($userId, $event);\n        \n        // Update item popularity features\n        if (isset($event['item_id'])) {\n            $this->updateItemPopularityFeatures($event['item_id'], $eventType, $timestamp);\n        }\n        \n        // Update category preferences\n        if (isset($event['category_id'])) {\n            $this->updateCategoryPreferences($userId, $event['category_id'], $eventType);\n        }\n        \n        // Update temporal features\n        $this->updateTemporalFeatures($userId, $timestamp, $eventType);\n    }\n    \n    /**\n     * Determine user activity level for cache management\n     */\n    private function getUserActivityLevel(string $userId): string\n    {\n        $cacheKey = \"user_activity_{$userId}\";\n        $activity = $this->cache->get($cacheKey);\n        \n        if (!$activity) {\n            // Calculate activity level based on recent behavior\n            $recentEvents = $this->behaviorRepository->getRecentEventCount($userId, 3600);\n            \n            if ($recentEvents >= 10) {\n                $level = 'hot';\n            } elseif ($recentEvents >= 3) {\n                $level = 'warm';\n            } else {\n                $level = 'cold';\n            }\n            \n            $this->cache->put($cacheKey, $level, 1800); // Cache for 30 minutes\n            return $level;\n        }\n        \n        return $activity;\n    }\n    \n    /**\n     * Generate fresh recommendations using hybrid approach\n     */\n    private function generateFreshRecommendations(string $userId, array $context): array\n    {\n        return $this->hybridRecommender->generateRecommendations($userId, array_merge($context, [\n            'real_time_mode' => true,\n            'include_explanations' => false, // Skip for performance\n            'max_recommendations' => 20\n        ]));\n    }\n    \n    /**\n     * Enhance cached recommendations with real-time context\n     */\n    private function enhanceWithRealTimeContext(array $cached, array $context): array\n    {\n        // Add real-time timestamps\n        $cached['served_at'] = time();\n        $cached['cache_hit'] = true;\n        \n        // Apply context-specific adjustments if needed\n        if (isset($context['current_page_category'])) {\n            $cached = $this->applyContextualBoosts($cached, $context);\n        }\n        \n        return $cached;\n    }\n    \n    /**\n     * Update user activity tracking\n     */\n    private function updateUserActivity(string $userId, string $eventType): void\n    {\n        $activityKey = \"user_activity_{$userId}\";\n        $sessionKey = \"user_session_{$userId}\";\n        \n        // Update activity counter\n        $this->cache->increment($activityKey, 1, 3600);\n        \n        // Update session information\n        $sessionData = $this->cache->get($sessionKey, []);\n        $sessionData['last_activity'] = time();\n        $sessionData['event_count'] = ($sessionData['event_count'] ?? 0) + 1;\n        $sessionData['last_event_type'] = $eventType;\n        \n        $this->cache->put($sessionKey, $sessionData, 3600);\n    }\n    \n    /**\n     * Check if cache is still valid based on user activity\n     */\n    private function isCacheValid(array $cached, string $activityLevel): bool\n    {\n        $cacheAge = time() - ($cached['generated_at'] ?? 0);\n        $maxAge = self::CACHE_LAYERS[$activityLevel];\n        \n        return $cacheAge < $maxAge;\n    }\n    \n    /**\n     * Validate incoming event data\n     */\n    private function validateEvent(array $event): void\n    {\n        $required = ['user_id', 'event_type', 'timestamp'];\n        \n        foreach ($required as $field) {\n            if (!isset($event[$field])) {\n                throw new \\InvalidArgumentException(\"Missing required field: {$field}\");\n            }\n        }\n        \n        if (!in_array($event['event_type'], self::HIGH_PRIORITY_EVENTS)) {\n            // Allow but log unknown event types\n            $this->logger->warning('Unknown event type', [\n                'event_type' => $event['event_type']\n            ]);\n        }\n    }\n    \n    /**\n     * Get event processing priority\n     */\n    private function getEventPriority(array $event): string\n    {\n        return in_array($event['event_type'], self::HIGH_PRIORITY_EVENTS) ? 'high' : 'normal';\n    }\n    \n    /**\n     * Generate cache key for user recommendations\n     */\n    private function generateCacheKey(string $userId, array $context): string\n    {\n        $contextHash = md5(serialize($context));\n        return \"recommendations_{$userId}_{$contextHash}\";\n    }\n    \n    /**\n     * Invalidate user's recommendation cache\n     */\n    private function invalidateUserCache(string $userId): void\n    {\n        $pattern = \"recommendations_{$userId}_*\";\n        $this->cache->deletePattern($pattern);\n    }\n    \n    /**\n     * Check if user is currently active\n     */\n    private function isUserCurrentlyActive(string $userId): bool\n    {\n        $sessionKey = \"user_session_{$userId}\";\n        $session = $this->cache->get($sessionKey);\n        \n        if (!$session) {\n            return false;\n        }\n        \n        $lastActivity = $session['last_activity'] ?? 0;\n        return (time() - $lastActivity) < 300; // Active within last 5 minutes\n    }\n    \n    /**\n     * Get fallback recommendations for error cases\n     */\n    private function getFallbackRecommendations(string $userId, array $context): array\n    {\n        // Try to get from global trending cache\n        $trending = $this->cache->get('global_trending_recommendations');\n        \n        if ($trending) {\n            return [\n                'recommendations' => $trending,\n                'fallback' => true,\n                'type' => 'trending'\n            ];\n        }\n        \n        // Return empty recommendations as last resort\n        return [\n            'recommendations' => [],\n            'fallback' => true,\n            'type' => 'empty',\n            'error' => 'No fallback recommendations available'\n        ];\n    }\n}